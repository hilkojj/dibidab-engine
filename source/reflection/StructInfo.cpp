#include "StructInfo.h"

#include <utils/string_utils.h>
#include <utils/gu_error.h>

#include <map>

namespace
{
    std::map<std::string, dibidab::StructInfo> &getAllStructInfos()
    {
        static std::map<std::string, dibidab::StructInfo> infos;
        return infos;
    }
}

const std::map<std::string, dibidab::StructInfo> &dibidab::getAllStructInfos()
{
    return ::getAllStructInfos();
}

const dibidab::StructInfo *dibidab::findStructInfo(const char *structNameOrId)
{
    /*
     * NOTE: In some cases, we want to find StructInfo using a incomplete/non-global id.
     * For example:
     * We want to find the StructInfo for dibidab::ecs::Parent, using "ecs::Parent" or just "Parent".
     * This happens because these non-global ids can be found in VariableInfo::typeName.
     * Therefore, keys in the StructInfos map are the name without namespaces.
     * That means having multiple structs with the same name (despite being in different namespaces) in .dibidab.h headers is not supported.
     *
     * TODO: Allow multiple structs with the same name, if they are in different namespaces:
     *  - Some functions generated by the header tool need to have a more specific name or should be moved into the struct's namespace.
     *  - Find the complete struct id (including all namespaces) for an incomplete/non-global id:
     *      - Can be done using the namespaces of the struct containing the VariableInfo.
     */
    const std::string structName = su::split(structNameOrId, "::").back();

    const auto &infos = ::getAllStructInfos();
    auto it = infos.find(structName);
    if (it != infos.end())
    {
        return &it->second;
    }
    return nullptr;
}

void dibidab::registerStructInfo(const dibidab::StructInfo &info)
{
    // NOTE: read note in findStructInfo
    const std::string name = su::split(info.id, "::").back();
    if (findStructInfo(name.c_str()))
    {
        throw gu_err("Struct already registered: " + name);
    }
    ::getAllStructInfos().insert({ name, info });
}
